// Generated by CoffeeScript 2.0.0-beta4
void function () {
    var async, existsSync, fs, ibrik, istanbul, mkdirp, path, which, instrumenter, transformer, fn;
    fs = require('fs');
    path = require('path');
    async = require('async');
    ibrik = require('./ibrik');
    istanbul = require('istanbul');
    mkdirp = require('mkdirp');
    which = require('which');
    existsSync = fs.existsSync || path.existsSync;
    module.exports = function (opts, callback) {
        var output, excludes, cache$, cmd, file, transformFn;
        cache$ = opts._;
        cmd = cache$[0];
        file = cache$[1];
        output = opts.output || opts.o;
        excludes = opts.x;
        if (!file)
            return callback('Need a filename argument for the ' + cmd + ' command!');
        if (!existsSync(file)) {
            try {
                file = which.sync(file);
            } catch (e$) {
                return callback('Unable to resolve file [' + file + ']');
            }
        } else {
            file = path.resolve(file);
        }

        if (output) {
            output = path.resolve(output);
        }
        transformFn = function (transformer, verbose) {
            return function (code, filename) {
                var changed, transformed;
                changed = false;
                if (verbose)
                    console.error('Instrument [' + filename + ']');
                try {
                    transformed = transformer(code, filename);
                    changed = true;
                } catch (ex) {
                    console.error('Instrument error; return original code');
                    console.error(ex);
                    transformed = code;
                }
                return {
                    code: transformed,
                    changed: changed
                };
            };
        };
        instrumenter = new ibrik.Instrumenter();
        transformer = instrumenter.instrumentSync.bind(instrumenter);
        fn = transformFn(transformer, true);
        return function () {
            var stats = fs.statSync(file),
                filesFor,
                stream;
            if (stats.isDirectory()) {
                try {
                    filesFor = require('../node_modules/istanbul/lib/util/file-matcher').filesFor;
                } catch (e) {
                    return callback(e);
                }
                if (!output) {
                    return callback('Need an output directory [-o <dir>] when input is a directory!');
                }
                if (output === file) {
                    return callback('Cannot instrument into the same directory/ file as input!');
                }
                mkdirp.sync(output);
                filesFor({
                    root: file,
                    includes: ['**/*.coffee'],
                    excludes: excludes || ['**/node_modules/**'],
                    relative: true
                }, function (err, files) {
                    if (err) {
                        return callback(err);
                    }
                    function processFiles(instrumenter, inputDir, outputDir, relativeNames) {
                        var processor = function (name, callback) {
                                var inputFile = path.resolve(inputDir, name),
                                    outputFile = path.resolve(outputDir, name),
                                    oDir = path.dirname(outputFile),
                                    instrumented;
                                try {
                                    mkdirp.sync(oDir);
                                    instrumented = instrumenter(fs.readFileSync(inputFile, 'utf8'), inputFile).code;
                                    fs.writeFileSync(outputFile, instrumented, 'utf8');
                                    return callback(null,name);
                                } catch (e) {
                                    return callback(e, name);
                                }
                            },
                            q = async.queue(processor, 10),
                            errors = [],
                            count = 0,
                            startTime = new Date().getTime();

                        q.push(relativeNames, function (err, name) {
                            var inputFile, outputFile;
                            if (err) {
                                errors.push({ file: name, error: err.message || err.toString() });
                                inputFile = path.resolve(inputDir, name);
                                outputFile = path.resolve(outputDir, name);
                                fs.writeFileSync(outputFile, fs.readFileSync(inputFile));
                            }

                            if (count % 100 === 0) {
                                process.stdout.write('.');
                            }
                            count += 1;
                        });

                        q.drain = function () {
                            var endTime = new Date().getTime();
                            console.log('\nProcessed [' + count + '] files in ' + Math.floor((endTime - startTime) / 1000) + ' secs');
                            if (errors.length > 0) {
                                console.log('The following ' + errors.length + ' file(s) had errors and were copied as-is');
                                console.log(errors);
                            }
                        };
                    }

                    processFiles(fn, file, output, files);

                });
            } else {
                if (output) {
                    stream = fs.createWriteStream(output);
                } else {
                    stream = process.stdout;
                }
                stream.write(fn(fs.readFileSync(file, 'utf8'), file).code);
                if (stream !== process.stdout) {
                    stream.end();
                }
            }
        }();
    };
}.call(this);
